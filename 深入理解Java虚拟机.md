
#第2章 Java内存区域与内存溢出异常
##2.2 运行时数据区
###2.2.1 程序计数器
    程序计数器是一块（较小）的内存空间，可看作当前线程的行号指示器。在jvm概念模型里，字节码解释器工作时是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令。
    由于java虚拟机的多线程是通过轮流切换并分配处理器执行时间的方式来实现的，那么任何时刻，一个处理器都指回执行一条线程中的指令。为了线程切换后能恢复到正确的执行位置，每个线程需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，所以是"线程私有"的内存。
    如果线程正在执行一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域。
###2.2.2 Java虚拟机栈
    Java虚拟机栈是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是`Java方法`执行的内存模型，每个方法执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。
    局部变量表存放了编译期可知的各种基本数据类型（boolean/byte/char/short/int/float/long/double）、对象引用和returnAddress（指向了一条字节码指令的地址）。
    其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的占1个。局部变量表所需的空间在编译期间完成分配，所以运行时，这个空间是完全确定的，方法运行期间不会改变局部变量表的大小。
    这个区域有两种异常：1、栈深度大于所允许的，StackOverflowError；2、虚拟机栈可动态扩展，无法申请到足够的内存，会抛出outOfMemoryError。
###2.2.3 本地方法栈
    本地方法栈与虚拟机栈所发挥的作用是非常相似的，区别是，java虚拟机栈为执行java方法服务的，而本地方法栈是为native方法服务的。
    HotSpot虚拟机直接把本地方法栈和java虚拟机栈合二为一。
###2.2.4 Java堆
    Java堆是被所有线程共享的一块区域，在虚拟机启动时创建。次区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术使得所有的对象都分配在堆上也渐渐变得不那么`绝对`了。
    Java堆是垃圾收集器管理的主要区域，因此也被称作`GC`堆。从内存回收的角度看，由于现代收集器基本采用分代收集算法，所以堆可细分为：新生代和老年代；再细一点有Eden空间、From Survior空间、To Survior 空间等。从内存分配的角度看，线程共享的Java堆中可能划分出多个`线程私有`的分配缓冲区。进一步划分的目的是更好的回收内存，或更快的分配内存。
    Java堆可以处理物理上不连续的内存空间中，只要逻辑上连续的即可，就像我们的磁盘空间一样。可扩展堆大小的配置是（-Xmx 和 -Xms），当堆中没完成实例分配切堆也无法再扩展时，抛出OOM异常。
###2.2.5 方法区
    方法区与Java堆一样是线程共享的区域，它用于存储已被虚拟机加载的类信息、常亮、静态变量、即时编译器编译后的代码等数据。别名是`非堆`或`永久代`。
###2.2.6 运行时常量池
    运行时常量池是方法区的一部分。Class文件中除了类的版本、字段、方法、接口等描述信息外，还有一项是运行时常量池（Constant Pool Table）用于存放`编译期`生成的各种字面量和符号引用，这部分内容将在类加载后进入方法取得运行时常量池中存放。
    运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，运行期也可能将新的常亮放入池中，这种特性被开发人员利用得比较多的便是String的intern()方法。常量池是方法区的一部分，自然受方法区内存限制，也会OOM。
###2.2.7 直接内存
    直接内存并不是虚拟机运行时数据区的一部分。JDK1.4中加入了NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用native方法直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能显著提升性能，避免了Java堆和native堆中来回复制数据。
    受本机总内存和处理器寻址空间的限制。
    
##2.3 HotSpot虚拟机对象探秘
    探讨Java堆中对象分配、布局和访问全过程
###2.3.1 对象的创建
    虚拟机遇到一个new指令时：
        1，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有先类加载。
        2，在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从java堆中划分出来。有指针碰撞和空闲列表的分配方式 P44，选择哪种分配方式由java堆是否规整决定。
        3，内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。
        4，接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例（实例和class的映射）、如何才能找到类的元数据信息、对象的哈希吗、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。
        5，上面都完成后，从虚拟机的视角来看，一个新对象已经产生了，但从Java程序的视角来看，对象才刚刚开始——<init>方法还没有执行，所有的字段还都是零。所以一般来说（由字节码中是否跟随invokespecial指令决定），执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算构造出来。
###2.3.2 对象的内存布局
    对象在内存中存储的布局可分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
    对象头包括两部分信息：
        第一部分用于存储对象自身的运行时数据，如哈希吗、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，称之为`Mark Word`标记字。
        第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
        另外，如果对象是一个Java数据，对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数据的元数据中却无法确定数组大小。
    实例数据是代码中定义的各种类型的字段内容。
    对齐填充不是必然存在的，也没特别含义，仅仅起着占位符的作用。对象大小必须是8字节的整数倍。
###2.3.3 对象的访问定位
    建立对象是为了使用对象，Java程序需要通过栈上的reference数据来操作堆上的具体数据。目前主流的访问定位堆中对象位置的方式有`使用句柄`和`直接指针`两种。
    `使用句柄`:`Java堆`中划分出一块内存区域来存放句柄池，`栈`上的reference存储对象的句柄地址，而句柄池中的句柄存放实例数据与类型数据各自的具体地址信息（对象内存布局中Header中的第二部分类型指针不是存类型数据了吗，怎么还存）。
        优点：在对象被移动时只改变句柄中实例对象的数据指针，而java栈中reference本身不需要修改（指向句柄池中句柄的地址）。
    `直接指针`:reference中存储的直接就是对象地址。
        优点：节省了一次指针定位的开销，reference->实例，而不是reference->句柄池->实例，速度更快。
    
#第3章 垃圾收集器与内存分配策略
##3.1 概述
    哪些内存需要回收？
    什么时候回收？
    如何回收？
    
    程序计数器、虚拟机栈、本地方法栈3个区域随着线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着入栈出栈操作。
    每一个栈帧中分配多少内存在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，方法或线程结束时，自然而然就随着回收了。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也不一样，只有在运行期才知道会创建哪些对象，内存分配和回收是动态的，GC收集器关注的是这部分内存。
##3.2 对象已死吗
    在进行垃圾回收前，第一件事是确定这些对象哪些还`存活`，哪些已经`死亡`。
###3.2.1 引用计数法
    给对象添加一个引用计数器，每当一个地方引用它时，计数器值加1；引用失效时，值就减1；任何时刻，计数器为0的对象就是不能再被使用的对象。
    主流虚拟机不采用这种方法的原因是：很难解决对象间相互循环引用的问题。
###3.2.2 可达性分析算法
    Java、C#的主流实现中，都是通过该算法判定对象是否存活。
    基本思想：通过一系列称为`GC Roots`的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象死亡。
    在Java语言中，可作为GC Roots的对象有：
        虚拟机栈（栈帧中的本地变量表）中引用的对象（reference->句柄 或 reference->对象）。
        方法区中类静态属性引用的对象。
        方法区中常亮引用的对象。
        本地方法栈中JNI（即一般所说的native方法）引用的对象。
###3.2.3 再谈引用
    无论引用计数法还是可达性分析算法，都和对象的"引用"有关。
    Java中引用定义的很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。定义很纯粹，但是太过狭隘。
    对于描述一些`食之无味，弃之可惜`的对象就显得无能为力。
    我们希望能描述这样一类对象：当内存空间还足够时，则保留在内存中；如果内存空间在进行垃圾收集后还是非常紧张，则可抛弃这些对象。
    JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强（Strong Reference）、软（Soft Reference）、弱（Weak Reference）、虚（Phantom Reference）4种，这4种引用强度依次减弱。
        强引用：Object obj = new Object(); 只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。
        软引用：软引用是用来描述一些可有但非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。
        弱引用：弱引用也是用来描述非必须的对象的，被弱引用关联的对象只能生存到下一次垃圾收集发生前。当GC时无论当前内存是否充足都会回收掉只被弱引用关联的对象。
        虚引用：也成为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例。为一个对象关联虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
###3.2.4生存还是死亡
    