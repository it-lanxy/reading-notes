
#第1章 Linux内核简介
##1.1 Unix的历史
    Unix是一个设计简洁，支持抢占式多任务、多线程、虚拟内存、换页、动态链接和TCP/IP网络的现代化操作系统。
    Unix强大的根本原因：
       1，Unix很简洁
       2，所有的东西都被当做文件对待。这种抽象使对数据和对设备的操作是通过一套相同的系统调用接口来进行的：open()/read()/write()/lseek()和close()。
       3，内核和相关的系统软件是用c语言编写的，移植能力强。
       4，Unix进程创建非常迅速，并且有一个非常独特的fork()系统调用。
       5，Unix提供了一套非常简单但又很稳定的进程间通信元语，快速简洁的进程创建过程使Unix的程序把目标放在一次执行保质保量地完成一个任务上，而简单稳定的进程间通信机制又可以保证这些单一目的的简单程序可以方便地组合在一起，去解决现实中变得越来越复杂的任务。
       正是由于这种策略和机制分离的设计理念，确保了Unix系统具备了清晰的层次化结构。
##1.2 追寻Linus足迹：Linux简介
    Linux是类Unix系统，但它不是Unix，开源
##1.3 操作系统和内核简介
    操作系统是指在整个系统中负责完成最基本功能和系统管理的那些部分。这些部分应该包括内核、设备驱动程序、启动引导程序、命令行shell或者其他种类的用户界面、基本的文件管理工具和系统工具。
    用户界面是操作系统的外在表象，内核才是操作系统的内在核心。
    通常一个内核由负责响应中断的中断服务程序，负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序和网络、进程间通信等系统服务程序共同组成。对于提供保护机制的现代操作系统来说，内核独立于普通应用程序，它一般处于系统态，拥有受保护的内存空间和访问硬件设备的所有权限。这种系统态和被保护起来的内存空间，统称为内核空间。
    相对的，应用程序在用户空间执行。它们只能看到允许它们使用的部分系统资源，而且只能使用某些特定的系统功能，不能直接访问硬件，也不能访问内核划给别人的内存范围，还有一些其他使用限制。
    当内核运行的时候，系统以内核态进入内核空间执行。
    而执行一个普通用户程序时，系统将以用户态进入以用户空间执行。
    
    系统中运行的应用程序通过系统调用与内核通信。应用程序通常调用库函数（比如C库函数）再由库函数通过系统调用界面，让内核代其完成各种不同的任务。
    当一个应用程序执行一条系统调用，我们说内核正在代其执行。如果进一步解释，在这种情况下，应用程序被称为通过系统调用在`内核空间运行`，而内核被称为运行于`进程上下文中`。这种交互关系————应用通过系统调用界面陷入内核————是应用程序完成其工作的基本行为方式。
    
    内核还要负责管理系统的硬件设备。当硬件设备想和系统通信的时候，它首先要发出一个异步的`中断信号`（中断机制）去打断处理器的执行，继而打断内核的执行。中断通常对应着一个中断号，内核通过这个中断号查找相应的中断服务程序，并调用这个程序响应和处理中断。
    举个例子，当你敲击键盘的时候，键盘控制器发送一个中断信号告知系统，键盘缓冲区有数据到来。内核注意到这个中断对应的中断号，调用相应的中断服务程序。该服务程序处理键盘数据然后通知键盘控制器可以继续输入数据了。
    
    许多操作系统的中断服务程序（通过中断号查找），都不在进程的上下文中执行（中断上下文）。它们在一个与所有进程都无关的、专门的中断上下文中运行。之所以存在这样一个专门的执行环境，就是为了保证中断服务程序能够在第一时间响应和处理中断请求，然后快速的退出。
    
    上下文代表着内核活动的范围：
        运行于用户空间，执行用户进程。
        运行于内核空间，处于进程上下文，代表某个特定的进程执行。
        运行于内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断。
    当CPU空闲时，内核就运行一个空进程，处于进程上下文，但运行于内核空间。
##1.4 Linux内核和传统Unix内核的比较
    Unix内核通常需要硬件系统提供页机制（MMU）以管理内存。这种页机制可以加强对内核空间的保护，并保证每个进程都可以运行于不同的虚地址空间上。
###单内核与微内核设计之比较
    操作系统内核可以分为两大阵营：单内核和微内核（第三阵营是外内核，主要用在科研系统上）。
    所谓单内核（单模块内核）就是把它从整体上作为一个单独的大过程来实现，同时也运行在一个单独的地址空间上（理论上有的处于内核空间，有的处于用户空间）。因此，这种内核通常以单个静态二进制文件的形式存放于磁盘中。所有内核服务都在这样的一个大内核地址空间上运行。内核之间的通信是微不足道的，因为大家都运行在内核态，并伸出同一地址空间：内核可直接调用函数，这与用户空间应用程序无区别。大多数Unix系统都设计为单模块，单模块具有简单和性能高的特点。
    微内核的功能被划分为多个独立的过程，每个过程叫做一个服务器。所有服务器都保持独立并运行在各自的地址空间上。因此，不能像单内核那样直接调用函数，而是通过消息传递处理微内核通信：系统采用了进程间通信（IPC)机制。通过IPC机制互通消息，互换`服务`。服务器的各自独立有效地避免了一个服务器失效祸及另一个。同样，模块化的系统允许一个服务器为了另一个服务器而换出。
    比较：
        因为IPC机制的开销多于系统调用，又因为会涉及内核空间与用户空间的上下文切换，因此，消息传递需要一定的周期，而单内核中简单的函数调用没有这些开销。结果，为减少开销，所有实际应用的基于微内核的系统都让大部分或全部服务器位于内核，这样，就可以直接调用函数，消除频繁的上下文切换。
    Linux是一个汲取了微内核精华的单内核，运行于单独的内核地址空间上，并借鉴微内核的模块化设计、抢占式内核、支持内核线程以及动态装载内核模块的能力。Linux让所有事情都运行在内核态（微内核要求有强权），直接调用函数，无消息传递。      
    
    Linux和Unix系统之间的差异：
        Linux支持动态加载内核模块。
        Linux支持对称处理（SMP）机制。
        Linux内核可以抢占。Linux内核具有允许在内核运行的任务有限执行的能力。
        Linux对线程支持的实现比较有意思：内核并不区分线程和其他的一般进程。对于内核来说，所有的进程都一样————只不过是其中的一些共享资源而已。
        Linux提供具有设备类的面向对象的设备模型、热插拔时间，以及用户空间的设备文件系统（sysfs）
#第2章 从内核触发
    git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
#第3章 进程管理
    如何管理每个进程：它们在内核中如何被列举，如何创建，最终如何消亡。操作系统就是为了运行用户程序，因此，进程管理就是所有操作系统的心脏所在。
##3.1 进程
    进程就是处于执行期的程序（目标码存放在某种介质上）。但进程并不仅仅局限于一段可执行程序代码。通常进程还包含其他资源，像打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间及一个或多个执行线程，用来存放全局变量的数据段等。
    执行线程，简称线程（thread），是在进程中活动的对象。每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。内核调度的对象是线程，而不是进程。对Linux而言，线程只不过是一种特殊的进程罢了。
    在现代操作系统中，进程提供两种虚拟机制：虚拟处理器和虚拟内存（通过虚拟内存来感受虚拟处理器就是不是真实的处理器）。实际上许多进程正在分享一个处理器，但虚拟处理器让这些进程觉得自己独享处理器（此为虚拟处理器，虚在`独享`的错觉）。而虚拟内存让进程在分配和管理内存时觉得自己拥有整个系统的所有内存资源（有这个必要么？）。有趣的是，线程之间可以共享虚拟内存，但是每个都拥有各自的虚拟处理器。
    进程在创建它的时候存活。linux系统中，这通常是调用fork()（fork实际上是由clone()系统调用实现的）系统的结果（fork 创建进程），该系统调用通过复制一个现有的进程来创建一个全新的进程。父进程调用fork()操作创建子进程。在fork()调用结束时，在返回点这个相同位置上，父进程恢复执行，子进程开始执行。fork()系统调用从内核返回两次：一次回到父进程，另一次回到新产生的子进程。紧接着调用exec()这组函数就可以创建新的地址空间，并把新的程序载入其中。最终调用exit()系统调用退出执行。终结进程并释放资源。父进程可以通过wait4()查询子进程是否终结（父进程拥有等待特定进程执行完毕的能力）。进程退出后被设置为僵死状态，直到父进程调用wait()或waitpit()位置。
####进程的另一个名字是任务（task）。本书中的任务通常指的是从内核观点看到的进程。
##3.2 进程描述符及任务结构
    内核把进程的列表存放在叫做任务队列（task list）的双向循环链表中。链表中的每一个项都是类型为task_struct（知道为啥进程也叫任务了吧）、称为进程描述符（process descriptor）的结构，里面有pid。结构体定义在：linux/include/linux/sched.h:637。进程描述符中包含一个具体进程的所有信息。
    task_struct在32位机器上，大约有1.7KB。包含了内核管理一个进程所需的所有信息，包括：它打开的文件，进程的地址空间，挂起的信号，进程的状态等。
###3.2.1 分配进程描述符
    Linux通过slab分配器分配task_struct结构，这样能达到对象复用（Unix的一个特点是创建进程迅速：复用可避免动态分配和释放所带来的资源消耗）和缓存着色（cache coloring）的目的。slab分配器动态生成task_struct，只需在栈底或栈顶创建一个新的结构struct thread_info，thread_info有一个指向进程描述符（task_struct）的指针。
###3.2.2 进程描述符的存放
    内核通过一个唯一的进程标识符（process identification valud）或PID来标识每个进程。PID是一个int类型的数，最大值默认设置为32768（short int短整形的最大值）可通过linux/include/linux/threads.h:28 修改，这个最大值是系统中允许同时存在的进程最大数目，修改/proc/sys/kernel/pid_max来提高上限。PID存放在task_struct进程描述符里。
###3.2.3 进程状态
    进程描述符task_struct中的state域描述了进程的当前状态。系统中的每个进程都必然处于五种进程状态中的一种。
        TASK_RUNNING（运行）————进程可执行的：它或者正在执行，或者在运行队列中等待执行。进程在用户空间中执行的唯一状态。
        TASK_INTERRUPTIBLE（可中断）————进程正在休眠（也就是说它被阻塞），等待某些条件的达成。一旦这些条件达成，内核就会把进程状态设置为运行。处于此状态的进程也会因为接收到信号而提前被唤醒并随时准备投入运行（Thread.sleep可被提前唤醒吗？）。
        TASK_UNINTERRUPTIBLE（不可中断）————就算是接收到信号也不会被唤醒或准备投入运行外，这个状态与可打断状态相同（进程正在休眠、阻塞）。
        _TASK_TRACED————被其他进程跟踪的进程，例如通过ptrace对调试程序进行跟踪
        _TASK_STOPPED（停止）————进程停止执行
###3.2.4 设置当前进程状态
    内核经常需要调整某个进程的状态。这时最好使用set_task_state(task，state)函数
    该函数将指定的进程设置为指定的状态。必要的时候，它会设置内存屏障来强制其他处理器作重新排序。
###3.2.5 进程上下文
    可执行程序时进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行。一般程序在用户地址空间执行。当一个程序执行了系统调用或者出发了某个异常，它就陷入了内核空间，内核处于进程上下文，代表用户进程执行（系统调用）。除非在此间隙有更高优先级的进程需要执行并由调度器做出了相应调整，否则在内核退出的时候，程序恢复在用户空间会继续执行。
###3.2.6 进程家族树
    所有进程都是PID为1的进程的后代。每个进程必有一个父进程，同一个父进程的称为兄弟。
##3.3 进程的创建
    别的操作系统都会提供产生（spawn）进程的机制，首先在新的地址空间里创建进程，读入可执行文件，最后开始执行。
    Unix把上述步骤分解到两个单独的函数中去执行：fork()和exec()。首先fork()通过拷贝当前进程创建一个子进程。子进程与父进程的区别仅仅在于PID、PPID（父进程进程号）和某些资源和统计量（例如，挂起的信号，它没必要集成）。exec()函数负责读取可执行文件并将其载入地址空间开始运行。
###3.3.1 写时拷贝
    传统的fork()系统调用直接把所有的资源复制给新创建的进程。这种实现过于简单并且效率低下，因为它拷贝的数据也许并不共享，更糟的情况是，如果新进程打算立即执行一个新的映像，那么拷贝没有意义。Linux的fork()使用写时拷贝(copy-on-write)页实现。写时拷贝是一种可以推迟（只有需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝）甚至免除拷贝数据（只需要只读，不涉及写，甚至俩进程一点关系都没有，不像redis fork 父子进程）的技术。内核此时并不复制整个进程地址空间，而是让父进程和子进程共享同一个拷贝。
    fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。
    写时拷贝技术可以避免拷贝大量根本就不会被使用的数据（地址空间里常常包含数十兆的数据）。由于Unix强调进程快速执行的能力，所以这个优化很重要。
###3.3.2 fork()
    Linux通过clone()系统调用实现fork()。这个调用通过一系列的参数标志来指明父、子进程需要共享的资源。过程详询p27。
###3.3.3 vfork()
    除了不拷贝父进程的页表项外，vfork()系统调用和fork()的功能相同。子进程作为父进程的一个单独的线程在它的地址空间里运行，父进程被阻塞，直到子进程退出或执行exec()。子进程不能向地址空间写入。过程详询p27。
##3.4 线程在Linux中的实现
    线程机制是现代编程技术中常用的一种抽象概念。该机制提供了在同一程序内共享内存地址空间运行的一组线程。这些线程还可以共享打开的文件和其他资源。线程机制支持并发程序设计技术，在多处理器系统上，它也能保证真正的并行处理。
    Linux实现线程的机制非常独特。从内核的角度来说，它并没有线程这个概念。Linux把所有的线程都当做进程来实现。内核并没有特别的调度算法或是定义特别的数据结构来表征线程。相反，线程仅仅被视为一个与其他进程共享某些资源的进程。每个线程都拥有唯一隶属于自己的task_struct（进程描述符），所以在内核中，它看起来就像是一个普通的进程（只是线程和其他一些进程共享某些资源，如地址空间）。
    在Windows等操作系统，在内核中提供了专门支持线程的机制（这些系统常常把线程称作轻量级进程）。与Linux有差异。在其他系统中，相较于重量级进程，线程被抽象成一种消耗较少资源，运行迅速的执行单元。而对于Linux来说，它只是一种进程间共享资源的手段（Linux进程本身够轻量了）。
    举个例子，加入我们有一个包含四个线程的进程，在提供专门线程支持的系统中，通常会有一个包含指向四个不同线程的指针的进程描述符。该描述符负责描述像地址空间、打开的文件这样的共享资源。线程本身再去描述它独占的资源。相反，Linux仅仅创建四个进程并分配四个普通的task_struct结构。建立这四个进程时指定他们共享某些资源，这是相当高雅的做法。
###3.4.1 创建线程
    线程的创建和普通进程的创建类似，只不过在调用clone()的时候需要传递一些参数标志来指明需要共享的资源。
###3.4.2 内核线程
    内核经常需要在后台执行一些操作。这种任务可以通过内核线程（kernel thread）完成————独立运行在内核空间的标准进程。内核线程和普通的进程间的区别在于内核线程没有独立的地址空间。只在内核空间运行，从来不切换到用户空间去。内核进程和普通进程一样，可以被调度和抢占。
##3.5 进程终结
    当一个进程终结时，内核必须释放它所占有的资源并把这以不幸告知其父进程。父进程检查后，进程所持有的所有内存都会被系统回收。
###3.5.1 删除进程描述符
    在调用do_exit()后，尽管线程已经僵死不能再运行了，但是系统还保留了它的进程描述符。系统此时保留进程描述符是可以上系统有办法在子进程终结后仍能获得它的信息。因此，进程终结时所需的清理工作和进程描述符的删除被分开执行。在父进程获得已终结的子进程的信息后，或者通知内核它不关注那些信息后，子进程的task_struct会被释放。
###3.5.2 孤儿进程造成的进退维谷
    如果父进程在子进程之前退出，必须有机制来保证子进程能找到一个新的父亲，否则这些称谓孤儿的进程就会退出时永远的处于僵死状态（进程描述符未删除），白白地消耗内存。对于这个问题，解决办法是给子进程在当前线程组内找一个线程作为父亲，如果不行，就让init做它们的父进程。
##3.6 小结
    考察了操作系统的核心概念————进程。讨论了进程的一般特性，为什么如此重要，以及进程与线程的关系。然后讨论了Linux如何存放和表示进程（task_struct 和thread_info）,如何创建进程（通过fork(),实际上最终是clone()），如何把新的执行映像装入到地址空间（通过exec()系统调用簇），以及进程最终如何消亡（强制或自愿地调用exit())。
    

    