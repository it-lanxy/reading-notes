
#第2章 Java内存区域与内存溢出异常
##2.2 运行时数据区
###2.2.1 程序计数器
    程序计数器是一块（较小）的内存空间，可看作当前线程的行号指示器。在jvm概念模型里，字节码解释器工作时是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令。
    由于java虚拟机的多线程是通过轮流切换并分配处理器执行时间的方式来实现的，那么任何时刻，一个处理器都指回执行一条线程中的指令。为了线程切换后能恢复到正确的执行位置，每个线程需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，所以是"线程私有"的内存。
    如果线程正在执行一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域。
###2.2.2 Java虚拟机栈
    Java虚拟机栈是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是`Java方法`执行的内存模型，每个方法执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。
    局部变量表存放了编译期可知的各种基本数据类型（boolean/byte/char/short/int/float/long/double）、对象引用和returnAddress（指向了一条字节码指令的地址）。
    其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的占1个。局部变量表所需的空间在编译期间完成分配，所以运行时，这个空间是完全确定的，方法运行期间不会改变局部变量表的大小。
    这个区域有两种异常：1、栈深度大于所允许的，StackOverflowError；2、虚拟机栈可动态扩展，无法申请到足够的内存，会抛出outOfMemoryError。
###2.2.3 本地方法栈
    本地方法栈与虚拟机栈所发挥的作用是非常相似的，区别是，java虚拟机栈为执行java方法服务的，而本地方法栈是为native方法服务的。
    HotSpot虚拟机直接把本地方法栈和java虚拟机栈合二为一。
###2.2.4 Java堆
    Java堆是被所有线程共享的一块区域，在虚拟机启动时创建。次区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术使得所有的对象都分配在堆上也渐渐变得不那么`绝对`了。
    Java堆是垃圾收集器管理的主要区域，因此也被称作`GC`堆。从内存回收的角度看，由于现代收集器基本采用分代收集算法，所以堆可细分为：新生代和老年代；再细一点有Eden空间、From Survior空间、To Survior 空间等。从内存分配的角度看，线程共享的Java堆中可能划分出多个`线程私有`的分配缓冲区。进一步划分的目的是更好的回收内存，或更快的分配内存。
    Java堆可以处理物理上不连续的内存空间中，只要逻辑上连续的即可，就像我们的磁盘空间一样。可扩展堆大小的配置是（-Xmx 和 -Xms），当堆中没完成实例分配切堆也无法再扩展时，抛出OOM异常。
###2.2.5 方法区
    方法区与Java堆一样是线程共享的区域，它用于存储已被虚拟机加载的类信息、常亮、静态变量、即时编译器编译后的代码等数据。别名是`非堆`或`永久代`。
###2.2.6 运行时常量池
    运行时常量池是方法区的一部分。Class文件中除了类的版本、字段、方法、接口等描述信息外，还有一项是运行时常量池（Constant Pool Table）用于存放`编译期`生成的各种字面量和符号引用，这部分内容将在类加载后进入方法取得运行时常量池中存放。
    运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，运行期也可能将新的常亮放入池中，这种特性被开发人员利用得比较多的便是String的intern()方法。常量池是方法区的一部分，自然受方法区内存限制，也会OOM。
###2.2.7 直接内存
    直接内存并不是虚拟机运行时数据区的一部分。JDK1.4中加入了NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用native方法直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能显著提升性能，避免了Java堆和native堆中来回复制数据。
    受本机总内存和处理器寻址空间的限制。
    
##2.3 HotSpot虚拟机对象探秘
    探讨Java堆中对象分配、布局和访问全过程
###2.3.1 对象的创建
    虚拟机遇到一个new指令时：
        1，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有先类加载。
        2，在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从java堆中划分出来。有指针碰撞和空闲列表的分配方式 P44，选择哪种分配方式由java堆是否规整决定。
        3，内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。
        4，接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例（实例和class的映射）、如何才能找到类的元数据信息、对象的哈希吗、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。
        5，上面都完成后，从虚拟机的视角来看，一个新对象已经产生了，但从Java程序的视角来看，对象才刚刚开始——<init>方法还没有执行，所有的字段还都是零。所以一般来说（由字节码中是否跟随invokespecial指令决定），执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算构造出来。
###2.3.2 对象的内存布局
    对象在内存中存储的布局可分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
    对象头包括两部分信息：
        第一部分用于存储对象自身的运行时数据，如哈希吗、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，称之为`Mark Word`标记字。
        第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
        另外，如果对象是一个Java数据，对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数据的元数据中却无法确定数组大小。
    实例数据是代码中定义的各种类型的字段内容。
    对齐填充不是必然存在的，也没特别含义，仅仅起着占位符的作用。对象大小必须是8字节的整数倍。
###2.3.3 对象的访问定位
    建立对象是为了使用对象，Java程序需要通过栈上的reference数据来操作堆上的具体数据。目前主流的访问定位堆中对象位置的方式有`使用句柄`和`直接指针`两种。
    `使用句柄`:`Java堆`中划分出一块内存区域来存放句柄池，`栈`上的reference存储对象的句柄地址，而句柄池中的句柄存放实例数据与类型数据各自的具体地址信息（对象内存布局中Header中的第二部分类型指针不是存类型数据了吗，怎么还存）。
        优点：在对象被移动时只改变句柄中实例对象的数据指针，而java栈中reference本身不需要修改（指向句柄池中句柄的地址）。
    `直接指针`:reference中存储的直接就是对象地址。
        优点：节省了一次指针定位的开销，reference->实例，而不是reference->句柄池->实例，速度更快。
    
#第3章 垃圾收集器与内存分配策略
##3.1 概述
    哪些内存需要回收？
    什么时候回收？
    如何回收？
    
    程序计数器、虚拟机栈、本地方法栈3个区域随着线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着入栈出栈操作。
    每一个栈帧中分配多少内存在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，方法或线程结束时，自然而然就随着回收了。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也不一样，只有在运行期才知道会创建哪些对象，内存分配和回收是动态的，GC收集器关注的是这部分内存。
##3.2 对象已死吗
    在进行垃圾回收前，第一件事是确定这些对象哪些还`存活`，哪些已经`死亡`。
###3.2.1 引用计数法
    给对象添加一个引用计数器，每当一个地方引用它时，计数器值加1；引用失效时，值就减1；任何时刻，计数器为0的对象就是不能再被使用的对象。
    主流虚拟机不采用这种方法的原因是：很难解决对象间相互循环引用的问题。
###3.2.2 可达性分析算法
    Java、C#的主流实现中，都是通过该算法判定对象是否存活。
    基本思想：通过一系列称为`GC Roots`的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象死亡。
    在Java语言中，可作为GC Roots的对象有：
        虚拟机栈（栈帧中的本地变量表）中引用的对象（reference->句柄 或 reference->对象）。
        方法区中类静态属性引用的对象。
        方法区中常亮引用的对象。
        本地方法栈中JNI（即一般所说的native方法）引用的对象。
###3.2.3 再谈引用
    无论引用计数法还是可达性分析算法，都和对象的"引用"有关。
    Java中引用定义的很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。定义很纯粹，但是太过狭隘。
    对于描述一些`食之无味，弃之可惜`的对象就显得无能为力。
    我们希望能描述这样一类对象：当内存空间还足够时，则保留在内存中；如果内存空间在进行垃圾收集后还是非常紧张，则可抛弃这些对象。
    JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强（Strong Reference）、软（Soft Reference）、弱（Weak Reference）、虚（Phantom Reference）4种，这4种引用强度依次减弱。
        强引用：Object obj = new Object(); 只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。
        软引用：软引用是用来描述一些可有但非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。
        弱引用：弱引用也是用来描述非必须的对象的，被弱引用关联的对象只能生存到下一次垃圾收集发生前。当GC时无论当前内存是否充足都会回收掉只被弱引用关联的对象。
        虚引用：也成为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例。为一个对象关联虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
###3.2.4生存还是死亡
    #第3章 垃圾收集器与内存分配策略
##3.1 概述
    哪些内存需要回收？
    什么时候回收？
    如何回收？
    
    程序计数器、虚拟机栈、本地方法栈3个区域随着线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行着入栈出栈操作。
    每一个栈帧中分配多少内存在类结构确定下来时就已知的，因此这几个区域的内存分配和回收都具备确定性，方法或线程结束时，自然而然就随着回收了。而Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也不一样，只有在运行期才知道会创建哪些对象，内存分配和回收是动态的，GC收集器关注的是这部分内存。
##3.2 对象已死吗
    在进行垃圾回收前，第一件事是确定这些对象哪些还`存活`，哪些已经`死亡`。
###3.2.1 引用计数法
    给对象添加一个引用计数器，每当一个地方引用它时，计数器值加1；引用失效时，值就减1；任何时刻，计数器为0的对象就是不能再被使用的对象。
    主流虚拟机不采用这种方法的原因是：很难解决对象间相互循环引用的问题。
###3.2.2 可达性分析算法
    Java、C#的主流实现中，都是通过该算法判定对象是否存活。
    基本思想：通过一系列称为`GC Roots`的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象死亡。
    在Java语言中，可作为GC Roots的对象有：
        虚拟机栈（栈帧中的本地变量表）中引用的对象（reference->句柄 或 reference->对象）。
        方法区中类静态属性引用的对象。
        方法区中常亮引用的对象。
        本地方法栈中JNI（即一般所说的native方法）引用的对象。
###3.2.3 再谈引用
    无论引用计数法还是可达性分析算法，都和对象的"引用"有关。
    Java中引用定义的很传统：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。定义很纯粹，但是太过狭隘。
    对于描述一些`食之无味，弃之可惜`的对象就显得无能为力。
    我们希望能描述这样一类对象：当内存空间还足够时，则保留在内存中；如果内存空间在进行垃圾收集后还是非常紧张，则可抛弃这些对象。
    JDK1.2之后，Java对引用的概念进行了扩充，将引用分为强（Strong Reference）、软（Soft Reference）、弱（Weak Reference）、虚（Phantom Reference）4种，这4种引用强度依次减弱。
        强引用：Object obj = new Object(); 只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。
        软引用：软引用是用来描述一些可有但非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。
        弱引用：弱引用也是用来描述非必须的对象的，被弱引用关联的对象只能生存到下一次垃圾收集发生前。当GC时无论当前内存是否充足都会回收掉只被弱引用关联的对象。
        虚引用：也成为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象的实例。为一个对象关联虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
###3.2.4 生存还是死亡
    即使在可达性分析算法中不可达的对象，也并非是`非死不可`的，这时候它们暂时处于`缓刑`阶段，要真正宣告一个对象的死亡，至少要经历两次标记过程：
        如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过（只能在finalize()方法中逃脱一次死亡），虚拟机将这两种情况都视为`没必要执行`。如果这个对象被判定为有必要执行finalize()方法，那么这个对象会将会放置在F-Queue的队列中，并在稍后由虚拟机自动建立的、低优先级的Finalizer线程去执行它。
        finalize()方法是对象逃脱死亡的最后一次机会（此为并非是非死不可的），稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize()中拯救自己————只要重新与引用链上的任何一个对象关联即可。
###3.2.5 回收方法区
    方法区、亦称之为永久代，主要回收两部分：废弃常量和无用的类。
    如何判断常量已废弃：没有任何对象引用"abc"常量，也没有其它地方引用这个字面量。
    如何判断类已无用：
        该类所有的实例都已被回收（堆中不存在该类的任何实例）。
        加载该类的ClassLoader已被回收。
        该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
    在大量使用反射、动态代理、GCLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，保证永久代不会溢出。
    
##3.3 垃圾收集算法
    只是介绍几种算法的思想及其发展过程
###3.3.1 标记-清除算法（Mark-Sweep）
    分为标记和清除两个阶段：
        首先标记待回收对象，
        标记完成后统一回收
    不足：效率低，标记和清除过程效率都不高；另一个是空间问题，标记清除之后有大量不连续的内存碎片，空间碎片太多可能会导致以后在程序中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
###3.3.2 复制算法（Copying）
    回收新生代；为了解决效率问题，复制算法应运而生。
    将内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后把已经使用的内存一次性清理掉。
    优点：每次是对整个半区进行内存回收，内存分配不用考虑内存碎片等复杂情况，只需要移动堆顶指针，按顺序分配内存即可，实现简单运行高效。
    缺点：只能使用一半的内存，内存浪费。
    新生代98%对象都是朝生夕死的，将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，当回收时，将其2块区域上的对象一次性复制到另一个Survivor，最后清理到Eden和刚才用的Survivor。
    所以其实不是1:1，而是9:1。
    但是我们没有办法保证每次回收都只不多于10%的对象存活，当Survivor空间不够时，需要依赖老年代进行分配担保。
###3.3.3 标记-整理算法
    老年代一般使用这种算法。
    两步骤：
        首先标记待回收对象。
        让所有存活的对象都向一端移动，然后直接清理掉端边界外的内存。
###3.3.4 分代收集算法
    这种算法没有别的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，新生代用复制算法，老年代用标记清理或标记整理算法进行回收。

##3.4 HotSpot的算法实现
    3.2和3.3节从理论上介绍了对象存活判定算法和垃圾收集算法，而在HotSpot虚拟机上实现这些算法时，biubiu对算法执行效率有严格的考量，才能保证高效运行。
###3.4.1 枚举根节点（枚举的含义是列出某些有穷序列集的所有成员的程序 GC Roots）
    从可达性分析中从GC Roots节点查找引用链这个操作为例（对象到GC Roots没有任何引用链相连时判定对象死亡，可回收），如果逐个检查引用，必然很消耗时间。
    可达性分析对执行时间的敏感还体现在GC停顿上，分析必须在一个能确保一致性的快照中进行————系统看起来像是冻结在某个时间点上，不可以在分析过程中对象引用关系还在不断的变化。所以GC进行时必须停顿所有Java执行线程（Sun将这个事件称之为`Stop the world`）
    Java虚拟机使用的都是准确式GC（第一张Exact VM那块讲过），所以系统STW时，不需要一个不漏的检查所有全局上下文和全局的引用位置，应当是有办法直接得知哪些地方存放着对象引用（把根节点缓存起来呗，通过oopMap的数据结构）。
    它是怎么做的？看书
###3.4.2 安全点（Safepoint）
    在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个问题随之而来：可能导致引用关系的变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，GC空间成本很高。
    实际上，hotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只在特定的位置记录了这些信息，这些位置称之为`安全点`，即程序只有在到达安全点时才能暂停开始GC。
    安全点不能太少（每次GC时间会太长），也不能太多（频繁GC）。所以，安全点的选定基本上是以程序`是否具有让程序长时间执行的特征`为标准进行选定的————因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，"长时间执行"的最明显特征是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。
    对于Safepoint来说，另一个需要考虑的问题是，如何让GC发生时让所有线程跑到最近的安全点上再停顿（STW）下来。
        方案1：抢占式中断。不需要线程中（run方法中的代码）的代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑在`安全点`上。现在没有虚拟机采用这种方式来暂停线程从而响应GC事件。
        方案2：主动式中断。该思想是当GC需要中断线城时，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为True时就自己中断挂起。轮询标志的地方和安全点时重合的，另外再加上创建对象需要分配内存的地方。
###3.4.3 安全区域
    使用Safepoint似乎已经完美的解决了如何进入GC的问题，但是实际却不一定。
    Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是程序`不执行`的时候呢？所谓程序不执行就是没有分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决。
    安全区域是指在一段代码片段中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。
    线程执行到Safe Region的代码时，首先标识自己已经进入了Safe Region，GC时，处于Safe Region的线程就不用管了。在线程要离开Safe Region的时候（假设正在GC呢，就不能动，不可以在GC过程中对象引用关系还在不断的变化），要收到可以离开Safe Region的信号才可以离开。

####以上是如何去发起内存回收的问题，但是虚拟机如何具体地进行内存回收动作还未涉及，因为内存回收如何进行时由虚拟机所采用的GC收集器决定的。

##3.5 垃圾收集器
    如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。
###3.5.1 Serial（串行）收集器（新生代）
    看名字就知道这是一个串行收集器，但它的`单线程`的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。
    Client模式下新生代默认收集器，优点：简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。
###3.5.2 ParNew（新的）收集器（新生代）
    ParNew其实就是Serial收集器的多线程版本。但是却是许多运行在Server模式下的虚拟机中首选的新生代收集器。
####在垃圾收集器的上下文语境中，并发和并行的概念如下
    并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
    并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。
###3.5.3 Parallel（并行['pærəlel]） Scavenge（清除['skævɪndʒ]） 收集器（新生代）
    其它的收集器关注点是尽可能缩短垃圾收集时用户线程的停顿时间。
    Parallel Scavenge收集器的目标是达到一个可控制的吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量 = 运行用户代码时间 /(用户运行代码时间 + 垃圾收集时间)。
    -XX:MaxGCPauseMillis ：控制最大垃圾收集停顿时间。
    -XX:GCTimeRatio ：直接设置吞吐量大小。
    -XX:+UseAdptiveSizePolicy：这是一个开关参数，打开之后，就不需要手工指定新生代大小(-Xmm)、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenuseSizeThreshold）等细节参数了，虚拟机根据当前系统运行情况收集性能信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应调节策略。
####3.5.3.1 ParNew 与 Parallel Scavenge 比较
    相同点：`新生代`，采用`复制算法`的`多线程`收集器。
    不同点：关注点不通（尽可能缩短垃圾收集时用户线程的停顿时间，尽可能满足用户吞吐量目标）
           此外 Parallel Scavenge 有 -XX:+UseAdptiveSizePolicy 自适应调节策略的配置开关。
###3.5.4 Serial Old（串行老年代）收集器（老年代）
    Serial Old 是 Serial的老年代版本，也是单线程收集器，使用`标记整理`算法。
    适用场景：
        Client模式下的虚拟机使用。
        作为CMS收集器的后备预案，在并发收集器发生Concurrent Mode Failure时使用。
###3.5.5 Parallel Old 收集器（老年代）
    Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和`标记-整理`算法。
    Parallel Scavenge 与 Parallel Old 组合在注重吞吐量以及CPU资源敏感的场合，大放异彩。
###3.5.6 CMS 收集器（Concurrent Mark Sweep 并发标记清除收集器）（老年代）
    一种以获取最短回收停顿时间为目标的收集器。
    CMS的`标记-清除`算法分为4个步骤：
        初始标记 STW（CMS initial mark）：仅仅标记一下GC Roots能直接关联到的对象（GC Roots关联到意味着对象没死）。
        并发标记 RUN（CMS concurrent mark）
        重新标记 STW（CMS remark）：修正并发标记期间因用户程序继续运作而导致标记产生变动的那部分对象的标记记录。
        并发清除 RUN（CMS concurrent sweep）
    其中初始标记和重新标记这两个步骤仍然需要STW，在整个回收过程中STW与RUN交替发生，所以是并发标记清理收集器。
    优点：并发收集；低停顿
    缺点：对CPU资源非常敏感。
         CMS收集器无法处理浮动垃圾（Floating Garbage），可能出现"Concurrent Mode Failure"失败而导致另一次Full GC的产生。
            CMS收集器与用户线程并发执行，伴随程序运行自然还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次GC中回收他们，这部分垃圾称为`浮动垃圾`，
            那么CMS就不能像其它收集器那样，等待老年代几乎满了再GC，需要给浮动垃圾留内存空间，-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比。如果预留空间不足，会"Concurrent Mode Failure"，启动后备预案，临时启用Serial Old来重新进行老年代收集，这样停顿时间就很长了。
         CMS是基于`标记-清除`的，大量空间碎片产生。空间碎片过多，会给大对象分配造成麻烦，无法找到足够大的空间不得不提前触发一次Full GC。为解决这个问题，CMS提供了两个参数：
            -XX:+UseCMSCompackAtFullCollection开关参数（默认开启）：顶不住要进行FullGC时开始一次内存碎片的合并整理过程，内存整理过程无法并发的，空间碎片问题没有课，但停顿时间不得不变长。
            -XX:CMSFullGCsBeforeCompacion：设置执行多少次不压缩的FullGC后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。
###3.5.7 G1（Garbage-First）收集器
    G1的特点：
        并行与并发
        分代收集
        空间整合
        可预测的停顿
    