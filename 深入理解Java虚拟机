
#第2章 Java内存区域与内存溢出异常
##2.2 运行时数据区
###2.2.1 程序计数器
    程序计数器是一块（较小）的内存空间，可看作当前线程的行号指示器。在jvm概念模型里，字节码解释器工作时是通过改变这个计数器的值来选取吓一跳需要执行的字节码指令。
    由于java虚拟机的多线程是通过轮流切换并分配处理器执行时间的方式来实现的，那么任何时刻，一个处理器都指回执行一条线程中的指令。为了线程切换后能恢复到正确的执行位置，每个线程需要一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，所以是"线程私有"的内存。
    如果线程正在执行一个java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是native方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java虚拟机规范中没有规定任何OOM情况的区域。
###2.2.2 Java虚拟机栈
    Java虚拟机栈是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是`Java方法`执行的内存模型，每个方法执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中入栈到出栈的过程。
    局部变量表存放了编译期可知的各种基本数据类型（boolean/byte/char/short/int/float/long/double）、对象引用和returnAddress（指向了一条字节码指令的地址）。
    其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的占1个。局部变量表所需的空间在编译期间完成分配，所以运行时，这个空间是完全确定的，方法运行期间不会改变局部变量表的大小。
    这个区域有两种异常：1、栈深度大于所允许的，StackOverflowError；2、虚拟机栈可动态扩展，无法申请到足够的内存，会抛出outOfMemoryError。
###2.2.3 本地方法栈
    本地方法栈与虚拟机栈所发挥的作用是非常相似的，区别是，java虚拟机栈为执行java方法服务的，而本地方法栈是为native方法服务的。
    HotSpot虚拟机直接把本地方法栈和java虚拟机栈合二为一。
###2.2.4 Java堆
    Java堆是被所有线程共享的一块区域，在虚拟机启动时创建。次区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术使得所有的对象都分配在堆上也渐渐变得不那么`绝对`了。
    Java堆是垃圾收集器管理的主要区域，因此也被称作`GC`堆。从内存回收的角度看，由于现代收集器基本采用分代收集算法，所以堆可细分为：新生代和老年代；再细一点有Eden空间、From Survior空间、To Survior 空间等。从内存分配的角度看，线程共享的Java堆中可能划分出多个`线程私有`的分配缓冲区。进一步划分的目的是更好的回收内存，或更快的分配内存。
    Java堆可以处理物理上不连续的内存空间中，只要逻辑上连续的即可，就像我们的磁盘空间一样。可扩展堆大小的配置是（-Xmx 和 -Xms），当堆中没完成实例分配切堆也无法再扩展时，抛出OOM异常。
###2.2.5 方法区
    方法区与Java堆一样是线程共享的区域，它用于存储已被虚拟机加载的类信息、常亮、静态变量、即时编译器编译后的代码等数据。别名是`非堆`或`永久代`。
###2.2.6 运行时常量池
    运行时常量池是方法区的一部分。Class文件中除了类的版本、字段、方法、接口等描述信息外，还有一项是运行时常量池（Constant Pool Table）用于存放`编译期`生成的各种字面量和符号引用，这部分内容将在类加载后进入方法取得运行时常量池中存放。
    运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，运行期也可能将新的常亮放入池中，这种特性被开发人员利用得比较多的便是String的intern()方法。常量池是方法区的一部分，自然受方法区内存限制，也会OOM。
###2.2.7 直接内存
    直接内存并不是虚拟机运行时数据区的一部分。JDK1.4中加入了NIO类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用native方法直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能显著提升性能，避免了Java堆和native堆中来回复制数据。
    受本机总内存和处理器寻址空间的限制。
    
##2.3 HotSpot虚拟机对象探秘
    探讨Java堆中对象分配、布局和访问全过程
###2.3.1 对象的创建
    虚拟机遇到一个new指令时：
        1，首先检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有先类加载。
        2，在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从java堆中划分出来。有指针碰撞和空闲列表的分配方式 P44，选择哪种分配方式由java堆是否规整决定。
        3，内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值。
        4，接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例（实例和class的映射）、如何才能找到类的元数据信息、对象的哈希吗、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。
        5，上面都完成后，从虚拟机的视角来看，一个新对象已经产生了，但从Java程序的视角来看，对象才刚刚开始——<init>方法还没有执行，所有的字段还都是零。所以一般来说（由字节码中是否跟随invokespecial指令决定），执行new指令之后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算构造出来。
###2.3.2 对象的内存布局
    对象在内存中存储的布局可分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。
    对象头包括两部分信息：
        第一部分用于存储对象自身的运行时数据，如哈希吗、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，称之为`Mark Word`标记字。
        第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
        另外，如果对象是一个Java数据，对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数据的元数据中却无法确定数组大小。
    实例数据是代码中定义的各种类型的字段内容。
    对齐填充不是必然存在的，也没特别含义，仅仅起着占位符的作用。对象大小必须是8字节的整数倍。
###2.3.3 对象的访问定位
    建立对象是为了使用对象，Java程序需要通过栈上的reference数据来操作堆上的具体数据。目前主流的访问定位堆中对象位置的方式有`使用句柄`和`直接指针`两种。
    `使用句柄`:`Java堆`中划分出一块内存区域来存放句柄池，`栈`上的reference存储对象的句柄地址，而句柄池中的句柄存放实例数据与类型数据各自的具体地址信息（对象内存布局中Header中的第二部分类型指针不是存类型数据了吗，怎么还存）。
        优点：在对象被移动时只改变句柄中实例对象的数据指针，而java栈中reference本身不需要修改（指向句柄池中句柄的地址）。
    `直接指针`:reference中存储的直接就是对象地址。
        优点：节省了一次指针定位的开销，reference->实例，而不是reference->句柄池->实例，速度更快。
    